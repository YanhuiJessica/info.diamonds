# **Proxies**
<br/>

> **Diamonds** follow the proxy pattern which deploys seperate **proxy and logic contracts.**

## **Proxy Overview**
- Proxy contract is what the user interacts with and holds the data
- Proxies are immutable but contain a [fallback function](https://docs.soliditylang.org/en/v0.8.9/contracts.html#fallback-function)
- The fallback function catches function calls and uses `delegatecall` to forward to logic contract
- `delegatecall` allows the proxy contract to use functions on the logic contract
- Logic contract stores functions, defined separate from data

<br/>


![Nextra](../public/proxy1.png)

<br/>
Instead of interacting with your smart contract directly, 
users interact with a proxy that holds the state and delegates execution to a logic contract for functionality.
Upgradeability is achieved by changing the reference to the logic contract in the proxy contract, 
so new functionality is used for executing all calls.

## **Transparent Proxy / Inline Proxy**
<br/>

![Nextra](../public/proxy3.png)

- Upgrade is handled by proxy contract.
- Deployment is more expensive.
- It makes things easy to maintain.

## **UUPS Proxy**

<br/>

![Nextra](../public/proxy4.avif)


<br/>

- uses the same delegate call pattern
- places upgrade logic in the logic contract instead of the proxy itself
- all functions defined on the logic contract
- the proxy is much smaller in size, making deployments cheaper




## **Multi-Facet Proxy (Diamond Pattern)**

Multi-Facet Proxies provide granular control of functionality by allowing the Proxy to add/remove/replace functions without impacting other logic.
